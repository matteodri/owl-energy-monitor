package com.matteodri.owlenergymonitor.services;


import java.io.IOException;
import java.net.DatagramPacket;
import java.net.InetAddress;
import java.net.MulticastSocket;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;

import com.matteodri.owlenergymonitor.model.electricity.Electricity;
import com.matteodri.owlenergymonitor.model.solar.Solar;
import com.matteodri.owlenergymonitor.util.AtomicDouble;
import com.matteodri.owlenergymonitor.util.MeasurementsUnmarshaller;

import io.micrometer.core.instrument.Gauge;
import io.micrometer.core.instrument.MeterRegistry;

/**
 * Service processing messages generated by the Owl Network.
 */
public class OwlMessageProcessorImpl implements OwlMessageProcessor {

    private static final Logger logger = LogManager.getLogger(OwlMessageProcessorImpl.class);

    private AtomicDouble currentElectricityConsumption = new AtomicDouble(0);
    private AtomicDouble todaysElectricityConsumption = new AtomicDouble(0);
    private AtomicDouble currentBatteryLevel = new AtomicDouble(0);
    private AtomicDouble currentElectricityGenerated = new AtomicDouble(0);
    private AtomicDouble currentElectricityExported = new AtomicDouble(0);
    private AtomicDouble todaysElectricityGenerated = new AtomicDouble(0);
    private AtomicDouble todaysElectricityExported = new AtomicDouble(0);

    private MeterRegistry meterRegistry;
    private MeasurementsUnmarshaller measurementsUnmarshaller;
    private ThreadPoolTaskScheduler threadPoolTaskScheduler;
    private String multicastAddress;
    private int multicastPort;
    private long multicastListenerDelay;

    public OwlMessageProcessorImpl(MeterRegistry meterRegistry, MeasurementsUnmarshaller measurementsUnmarshaller,
            ThreadPoolTaskScheduler threadPoolTaskScheduler, String multicastAddress, int multicastPort,
            long multicastListenerDelay) {
        this.meterRegistry = meterRegistry;
        this.measurementsUnmarshaller = measurementsUnmarshaller;
        this.threadPoolTaskScheduler = threadPoolTaskScheduler;
        this.multicastAddress = multicastAddress;
        this.multicastPort = multicastPort;
        this.multicastListenerDelay = multicastListenerDelay;
    }

    public void init() {
        setupMetrics(meterRegistry);

        // schedule task after a fixed delay of the last scheduled execution
        this.threadPoolTaskScheduler.scheduleWithFixedDelay(new MulticastListenerTask(), multicastListenerDelay);

    }

    @Override
    public void process(InetAddress fromAddress, String message) {
        logger.debug("Message received from {}: {}", fromAddress, message);

        if (message.startsWith("<electricity")) {
            // it's an electricity measurement summary
            Electricity electricityMeasurement = measurementsUnmarshaller.unmarshalElectricityXml(message);

            if (electricityMeasurement != null && electricityMeasurement.getChannels() != null
                    && electricityMeasurement.getChannels().size() >= 1) {
                if (electricityMeasurement.getChannels().get(0).getElectricityCurrent() != null) {
                    currentElectricityConsumption
                            .set(electricityMeasurement.getChannels().get(0).getElectricityCurrent().getValue());
                }
                if (electricityMeasurement.getChannels().get(0).getElectricityDay() != null) {
                    todaysElectricityConsumption
                            .set(electricityMeasurement.getChannels().get(0).getElectricityDay().getValue());// todaysElectricityConsumption.floatValue()
                }
            }

            if (electricityMeasurement != null && electricityMeasurement.getBattery() != null) {
                currentBatteryLevel.set(parsePercentage(electricityMeasurement.getBattery().getLevel()));
            }

            logger.debug(
                    "Metrics set:\ncurrentElectricityConsumption={}, todaysElectricityConsumption={}, "
                            + "currentBatteryLevel={}",
                    currentElectricityConsumption, todaysElectricityConsumption, currentBatteryLevel);
        } else {
            // it's a solar measurement summary
            Solar solarMeasurement = measurementsUnmarshaller.unmarshalSolarXml(message);

            if (solarMeasurement != null && solarMeasurement.getSolarCurrent() != null) {
                if (solarMeasurement.getSolarCurrent().getGenerating() != null) {
                    currentElectricityGenerated.set(solarMeasurement.getSolarCurrent().getGenerating().getValue());
                }
                if (solarMeasurement.getSolarCurrent().getExporting() != null) {
                    currentElectricityExported.set(solarMeasurement.getSolarCurrent().getExporting().getValue());
                }

                if (solarMeasurement.getSolarDay().getGenerated() != null) {
                    todaysElectricityGenerated.set(solarMeasurement.getSolarDay().getGenerated().getValue());
                }
                if (solarMeasurement.getSolarDay().getExported() != null) {
                    todaysElectricityExported.set(solarMeasurement.getSolarDay().getExported().getValue());
                }
            }
            logger.debug(
                    "Metrics set:\ncurrentElectricityGenerated={}, currentElectricityExported={}, "
                            + "todaysElectricityGenerated={}, todaysElectricityExported={}",
                    currentElectricityGenerated, currentElectricityExported, todaysElectricityGenerated,
                    todaysElectricityExported);
        }
    }

    private void setupMetrics(MeterRegistry meterRegistry) {
        Gauge.builder(MetricsUtils.ELECTRICITY_CONSUMPTION_CURRENT, currentElectricityConsumption, AtomicDouble::get)
                .description("Current electricity consumption (W)").register(meterRegistry);
        Gauge.builder(MetricsUtils.ELECTRICITY_CONSUMPTION_TODAY, todaysElectricityConsumption, AtomicDouble::get)
                .description("Today's electricity consumption (Wh)").register(meterRegistry);
        Gauge.builder(MetricsUtils.BATTERY_LEVEL_CURRENT, currentBatteryLevel, AtomicDouble::get)
                .description("Current battery level (%)").register(meterRegistry);
        Gauge.builder(MetricsUtils.ELECTRICITY_GENERATED_CURRENT, currentElectricityGenerated, AtomicDouble::get)
                .description("Current electricity generation (W)").register(meterRegistry);
        Gauge.builder(MetricsUtils.ELECTRICITY_EXPORTED_CURRENT, currentElectricityExported, AtomicDouble::get)
                .description("Current electricity exporting (W)").register(meterRegistry);
        Gauge.builder(MetricsUtils.ELECTRICITY_GENERATED_TODAY, todaysElectricityGenerated, AtomicDouble::get)
                .description("Today's generated electricity (Wh)").register(meterRegistry);
        Gauge.builder(MetricsUtils.ELECTRICITY_EXPORTED_TODAY, todaysElectricityExported, AtomicDouble::get)
                .description("Today's exported electricity (Wh)").register(meterRegistry);
    }

    /**
     * Given an input string like "56%" returns the floating-point percentage value (56.0). If format is not correct it
     * will return -1. This is intentional as to make it visible when metric is changing to -1.
     *
     * @param strPercentage percentage in string format including a trailing '%' sign
     * @return floating-point representation of percentage value
     */
    private double parsePercentage(String strPercentage) {
        double returnValue = -1;
        if (strPercentage != null && !strPercentage.isEmpty() && strPercentage.endsWith("%")) {
            try {
                returnValue = Double.valueOf(strPercentage.substring(0, strPercentage.indexOf('%')));
            } catch (NumberFormatException e) {
                logger.warn("Error parsing percentage '{}'", strPercentage);
            }
        }
        return returnValue;
    }

    class MulticastListenerTask implements Runnable {

        private MulticastSocket socket;
        private InetAddress address;
        private byte[] inBuf = new byte[2048];
        private DatagramPacket inPacket;

        public MulticastListenerTask() {
            try {
                socket = new MulticastSocket(multicastPort);
                address = InetAddress.getByName(multicastAddress);
                socket.joinGroup(address);
            } catch (IOException e) {
                logger.error("Error initialising multicast listener task", e);
                return;
            }

            inPacket = new DatagramPacket(inBuf, inBuf.length);
            logger.info("Listening to multicast address: {}:{}...", multicastAddress, multicastPort);
        }

        @Override
        public void run() {
            logger.debug("Waiting for packets on multicast socket");
            try {
                socket.receive(inPacket);
                String payload = new String(inBuf, 0, inPacket.getLength());

                process(inPacket.getAddress(), payload);

            } catch (IOException ioe) {
                logger.error("Error encountered listening to Owl messages", ioe);
            }
        }
    }

}
